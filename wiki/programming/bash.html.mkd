# Bash
## Bash简介
<!---date:2014-02-22-->
Bash是：

 * 简单的是一群系统命令的集合，实现代码的复用性
 * 命令有逻辑执行流程，如循环、判断

Bash适用于：

 * Linux系统管理
 * 日常工作自动化
 
Bash不适用于：
 
 * 要求计算效率或大型数学计算任务（一般使用C/Fortran）
 * 跨平台移植需求（一般使用C或Java）
 * 大型复杂的应用
 * 需要多维数组支持，数据结构支持或GUI支持等
 * 闭源需求
 

## 如何写脚本：

Bash脚本代码放在文本文件中，一般以.sh或.bash后缀形式表明其为shell脚本（实际上Linux下不是以后缀名识别程序属性，这与Windows不同）。

shell脚本一般格式：

```bash
#!/bin/bash
某些变量申明赋值
命令集合
exit 0
```

 * shell脚本第一行一般是#!/bin/sh，指明该脚本使用哪种脚本解释器(如果不指明，Linux下默认是bash)。使用#!/bin/sh是因为大多数的商业UNIX系统上都是以Bourne shell作为默认shell, 这样可以使脚本移植到non-Linux的机器上, 虽然这将会牺牲Bash一些独特的特征. 但是脚本将与POSIX 的sh标准相一致. #!也可以被忽略， 不过这样你的脚本文件就只能是一些命令的集合, 不能够使用shell内建的指令了

----

*编程技巧：*

平时注意收集具有代表性的“模板”代码，使用模块化的方式编写脚本，生成一个自己的代码库，最大程度上实现代码的复用。

使用变量代替写死的常量；将重复的代码放到一个函数中

----

 * exit 0表明脚本退出状态码，0表示执行成功，其他为失败;该语句也可以忽略。注：查询执行状态命令为`echo $?`

## Bash脚本执行方式

 * 命令行上直接`sh script.sh`或`bash script.sh` (不推荐使用sh <scriptname, 因为这禁用了脚本从stdin中读数据的功能. )
 * 脚本具有可执行属性: `chmod u+x script.sh; ./script.sh`
 * 把脚本移动到/usr/local/bin下, (当然是以root身份), 来让你的脚本对所有用户都有用. 这样以来, 用户就可以在命令行上简单的输入`scriptname [ENTER]`就可以运行这个脚本了,不需要后缀。


## 特殊字符

---------------------------------------------------------------------
 符号                含义                        举列    
-----    ----------------------------------  -----------
  #       脚本注释符（#!除外）                # This is a comment
  
  ;       命令分割符，用于一行写多个命令      cd /opt; ls 
  
 ;;       终止case选项                        case "$variable" in
											   abc) echo "abc" ;;
											   xyz) echo "xyz" ;;
											  esac
											  
  .       点命令，等价于source命令，bash       . ~/.bashrc
          内建命令;                            touch .zshrc   
		  dot作为文件名的一部分，如果放在文件  cd ../
		  名开头，为“隐藏”文件，如果作为目录名  
		  一个单独点代表当前工作目录;
		  正则表达式的通配符，匹配任何单个字符 

  "       双引号,"string"会阻止解释字符串中
          大部分特殊字符

  '       单引号，'string'阻止所有特殊字符解释
		  
  ,       逗号操作符，链接一系列算数操作，虽然   let "t2 = ((a = 9, 15/3))"
           里面所以内容都被运行，但只有最后一    #Set "a = 9" and "t2 = 15/3"
		   项被返回
		   
  \        转义符

  /       文件名路径分隔符；也可作除法操作符

  `       命令替换                                

  :       冒号，空命令，等价于“NOP”，也可以被     :
		   认为与shell内建命令true作用相同。      echo $? #0
		   ":"命令是一个bash内建命令，退出码
		   是"true"(0);
		  在if/then中作为占位符                   if condition
		                                          then : # do nothing
												  else
												     do something
												  fi
	      在一个二元命令中提供一个占位符;          : ${username=``whoami``}
	      与>重定向操作符结合使用清空文件;
	      
  !       取反操作符

  *       通配符，匹配给定目录下任何文件名；
          正则表达式中，匹配任意个数（包含0
		  个）的字符；算数操作符表示乘法；

  ?       测试操作符；通配符，匹配单个字符;
          正则表达式中也表示一个字符

  $       变量替换，变量前加上它引用变量值;
          正则表达式中表示行结束符

 ${}      参数替换

 $*
 $@       位置参数

 $?       退出状态码变量

 $$       进程ID变量

 ()       命令组，括号中命令列表将会作为一个子
          shell来运行；初始化数组用法

{x,y,z}    大括号扩展                              cp file22.{txt,backup}

 {}       代码块，创建一个匿名函数；与标准函数     {
          不同的是，在其中声明的变量，对于脚本      read line1;
		  其它部分代码来说还是可见的                read line2
	                                               } < $file
	                                               
{}\;      路径名，一般都在find命令中使用；这
          不是一个shell内建命令
          
 []       条件测试，[是shell内建test命令的一部
          分; 数组元素;

`[[]]`    测试

(())      整数扩展，扩展并计算在(())中整数表达
          式

 >         重定向
 &>
 >&
 >>
 <
 <>
 
 <<       用在here document中重定向

 <<<      用在here string中重定向

\<,\>      正则表达式中单词边界

 |         管道，stdou > stderr

 >|        强制重定向

 ||        逻辑或

 &         后台运行命令，在一个脚本中，
           命令和循环都可能运行在后台

 &&        逻辑与

 -          选项，前缀;                           
            用于重定向stdin或stdout[-]. ;        echo "whatever"|cat -
			"-"本身并不是一个bash操作，而是
			一个可以被特定的unix工具识别的
			选项，特指那些可以写输出到stdout
			的工具，比如tar,cat等;
			或指先前的目录 cd -

 =          等号，赋值操作

 +          加号;一种正则表达式

 %          取模;模式匹配操作

 ～         home目录，相当与$HOME内部变量，
            ~bozo是bozo的home目录

 ~+         当前工作目录，相当于$PWD内部变量

 ~-         先前工作目录，相当于$OLDPWD内部
           变量

 =~         正则表达式匹配

 ^          行首
 
---------------------------------------------------------------------


## 变量
### 变量替换
变量的名字就是变量保存值的地方. 引用变量的值就叫做变量替换. 

被一对双引号(" ")括起来的变量替换是不会被阻止的. 所以双引号被称为部分引用, 有时候又被称为"弱引用". 但是如果使用单引号的话(' '), 那么变量替换就会被禁止了, 变量名只会被解释成字面的意思, 不会发生变量替换. 所以单引号被称为全引用, 有时候也被称为"强引用". 

**注意$variable事实上只是`${variable}`的简写形式. 在某些上下文中`$variable`可能会引起错误, 这时候你就需要用`${variable}`了**

***注意, 在赋值的的时候, 等号前后一定不要有空格***

### 变量赋值

```
# 简单赋值
a=899
# 使用let算术复值
let b=16+5
# 在for循环中（伪赋值）
for c in 7 8 9 10
do
  echo -n "$a"
done
# 使用read命令赋值
read d
```

使用$(...)机制来进行变量赋值(这是一种比后置引用(反引号`)更新的一种方法). 事实上这两种方法都是命令替换的一种形式.

### 变量类型
不像其他程序语言一样, Bash并不对变量区分"类型". 本质上, Bash变量都是字符串. 但是依赖于具体的上下文, Bash也允许比较操作和整数操作. 其中的关键因素就是, 变量中的值是否只有数字. 


### 特殊变量
 * 局部变量
   
   代码块或函数中的变量

 * 环境变量
   
   脚本设置环境变量使用export命令，子进程继承父进程的环境变量，但子进程是
   能够export变量影响父进程的。

 * 位置参数

   命令行传递给脚本的参数：`$0,$1,$2,...`
   `$0`是脚本文件自身的名字，`$1`是第一个参数，依次类推，第10个参数开始
   要用大括号扩起来，如`${10}`

   `$*`和`$@`变量表示所有位置参数.

   `$#`表示位置参数个数。

   {}标记法提供了一种提取从命令行传递到脚本的最后一个位置参数的简单办法. 但是这种方法同时还需要使用间接引用.
   
```bash
args=$#
lastarg=${!args}
# 或 lastarg=${!#}
```

一些脚本可能会依赖于使用不同的调用名字, 来表现出不同的行为. 如果想要达到这种目的, 一般都需要在脚本中检查$0. 因为脚本只能够有一个真正的文件名, 如果要产生多个名字, 必须使用符号链接。
