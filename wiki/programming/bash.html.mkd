# Bash
## Bash简介
<!---date:2014-02-23-->
Bash是：

 * 简单的是一群系统命令的集合，实现代码的复用性
 * 命令有逻辑执行流程，如循环、判断

Bash适用于：

 * Linux系统管理
 * 日常工作自动化
 
Bash不适用于：
 
 * 要求计算效率或大型数学计算任务（一般使用C/Fortran）
 * 跨平台移植需求（一般使用C或Java）
 * 大型复杂的应用
 * 需要多维数组支持，数据结构支持或GUI支持等
 * 闭源需求
 

## 如何写脚本：

Bash脚本代码放在文本文件中，一般以.sh或.bash后缀形式表明其为shell脚本（实际上Linux下不是以后缀名识别程序属性，这与Windows不同）。

shell脚本一般格式：

```bash
#!/bin/bash
某些变量申明赋值
命令集合
exit 0
```

 * shell脚本第一行一般是#!/bin/sh，指明该脚本使用哪种脚本解释器(如果不指明，Linux下默认是bash)。使用#!/bin/sh是因为大多数的商业UNIX系统上都是以Bourne shell作为默认shell, 这样可以使脚本移植到non-Linux的机器上, 虽然这将会牺牲Bash一些独特的特征. 但是脚本将与POSIX 的sh标准相一致. #!也可以被忽略， 不过这样你的脚本文件就只能是一些命令的集合, 不能够使用shell内建的指令了

----

*编程技巧：*

平时注意收集具有代表性的“模板”代码，使用模块化的方式编写脚本，生成一个自己的代码库，最大程度上实现代码的复用。

使用变量代替写死的常量；将重复的代码放到一个函数中

----

 * exit 0表明脚本退出状态码，0表示执行成功，其他为失败;该语句也可以忽略。注：查询执行状态命令为`echo $?`

## Bash脚本执行方式

 * 命令行上直接`sh script.sh`或`bash script.sh` (不推荐使用sh <scriptname, 因为这禁用了脚本从stdin中读数据的功能. )
 * 脚本具有可执行属性: `chmod u+x script.sh; ./script.sh`
 * 把脚本移动到/usr/local/bin下, (当然是以root身份), 来让你的脚本对所有用户都有用. 这样以来, 用户就可以在命令行上简单的输入`scriptname [ENTER]`就可以运行这个脚本了,不需要后缀。


## 特殊字符

---------------------------------------------------------------------
 符号                含义                        举列    
-----    ----------------------------------  -----------
  #       脚本注释符（#!除外）                # This is a comment
  
  ;       命令分割符，用于一行写多个命令      cd /opt; ls 
  
 ;;       终止case选项                        case "$variable" in
											   abc) echo "abc" ;;
											   xyz) echo "xyz" ;;
											  esac
											  
  .       点命令，等价于source命令，bash       . ~/.bashrc
          内建命令;                            touch .zshrc   
		  dot作为文件名的一部分，如果放在文件  cd ../
		  名开头，为“隐藏”文件，如果作为目录名  
		  一个单独点代表当前工作目录;
		  正则表达式的通配符，匹配任何单个字符 

  "       双引号,"string"会阻止解释字符串中
          大部分特殊字符

  '       单引号，'string'阻止所有特殊字符解释
		  
  ,       逗号操作符，链接一系列算数操作，虽然   let "t2 = ((a = 9, 15/3))"
           里面所以内容都被运行，但只有最后一    #Set "a = 9" and "t2 = 15/3"
		   项被返回
		   
  \        转义符

  /       文件名路径分隔符；也可作除法操作符

  `       命令替换                                

  :       冒号，空命令，等价于“NOP”，也可以被     :
		   认为与shell内建命令true作用相同。      echo $? #0
		   ":"命令是一个bash内建命令，退出码
		   是"true"(0);
		  在if/then中作为占位符                   if condition
		                                          then : # do nothing
												  else
												     do something
												  fi
	      在一个二元命令中提供一个占位符;          : ${username=``whoami``}
	      与>重定向操作符结合使用清空文件;
	      
  !       取反操作符

  *       通配符，匹配给定目录下任何文件名；
          正则表达式中，匹配任意个数（包含0
		  个）的字符；算数操作符表示乘法；

  ?       测试操作符；通配符，匹配单个字符;
          正则表达式中也表示一个字符

  $       变量替换，变量前加上它引用变量值;
          正则表达式中表示行结束符

 ${}      参数替换

 $*
 $@       位置参数

 $?       退出状态码变量

 $$       进程ID变量

 ()       命令组，括号中命令列表将会作为一个子
          shell来运行；初始化数组用法

{x,y,z}    大括号扩展                              cp file22.{txt,backup}

 {}       代码块，创建一个匿名函数；与标准函数     {
          不同的是，在其中声明的变量，对于脚本      read line1;
		  其它部分代码来说还是可见的                read line2
	                                               } < $file
	                                               
{}\;      路径名，一般都在find命令中使用；这
          不是一个shell内建命令
          
 []       条件测试，[是shell内建test命令的一部
          分; 数组元素;

`[[]]`    测试

(())      整数扩展，扩展并计算在(())中整数表达
          式

 >         重定向
 &>
 >&
 >>
 <
 <>
 
 <<       用在here document中重定向

 <<<      用在here string中重定向

\<,\>      正则表达式中单词边界

 |         管道，stdou > stderr

 >|        强制重定向

 ||        逻辑或

 &         后台运行命令，在一个脚本中，
           命令和循环都可能运行在后台

 &&        逻辑与

 -          选项，前缀;                           
            用于重定向stdin或stdout[-]. ;        echo "whatever"|cat -
			"-"本身并不是一个bash操作，而是
			一个可以被特定的unix工具识别的
			选项，特指那些可以写输出到stdout
			的工具，比如tar,cat等;
			或指先前的目录 cd -

 =          等号，赋值操作

 +          加号;一种正则表达式

 %          取模;模式匹配操作

 ～         home目录，相当与$HOME内部变量，
            ~bozo是bozo的home目录

 ~+         当前工作目录，相当于$PWD内部变量

 ~-         先前工作目录，相当于$OLDPWD内部
           变量

 =~         正则表达式匹配

 ^          行首
 
---------------------------------------------------------------------


## 变量
### 变量替换
变量的名字就是变量保存值的地方. 引用变量的值就叫做变量替换. 

被一对双引号(" ")括起来的变量替换是不会被阻止的. 所以双引号被称为部分引用, 有时候又被称为"弱引用". 但是如果使用单引号的话(' '), 那么变量替换就会被禁止了, 变量名只会被解释成字面的意思, 不会发生变量替换. 所以单引号被称为全引用, 有时候也被称为"强引用". 

**注意$variable事实上只是`${variable}`的简写形式. 在某些上下文中`$variable`可能会引起错误, 这时候你就需要用`${variable}`了**

***注意, 在赋值的的时候, 等号前后一定不要有空格***

### 变量赋值

```
# 简单赋值
a=899
# 使用let算术复值
let b=16+5
# 在for循环中（伪赋值）
for c in 7 8 9 10
do
  echo -n "$a"
done
# 使用read命令赋值
read d
```

使用$(...)机制来进行变量赋值(这是一种比后置引用(反引号`)更新的一种方法). 事实上这两种方法都是命令替换的一种形式.

### 变量类型
不像其他程序语言一样, Bash并不对变量区分"类型". 本质上, Bash变量都是字符串. 但是依赖于具体的上下文, Bash也允许比较操作和整数操作. 其中的关键因素就是, 变量中的值是否只有数字. 


### 特殊变量
 * 局部变量
   
   代码块或函数中的变量

 * 环境变量
   
   脚本设置环境变量使用export命令，子进程继承父进程的环境变量，但子进程是
   能够export变量影响父进程的。

 * 位置参数

   命令行传递给脚本的参数：`$0,$1,$2,...`
   `$0`是脚本文件自身的名字，`$1`是第一个参数，依次类推，第10个参数开始
   要用大括号扩起来，如`${10}`

   `$*`和`$@`变量表示所有位置参数.

   `$#`表示位置参数个数。

   {}标记法提供了一种提取从命令行传递到脚本的最后一个位置参数的简单办法. 但是这种方法同时还需要使用间接引用.
   
```bash
args=$#
lastarg=${!args}
# 或 lastarg=${!#}
```

一些脚本可能会依赖于使用不同的调用名字, 来表现出不同的行为. 如果想要达到这种目的, 一般都需要在脚本中检查$0. 因为脚本只能够有一个真正的文件名, 如果要产生多个名字, 必须使用符号链接。

## 引用
### 引用变量
引用意味着得到原有的字面意思，使用双引号扩起来保护字符串中特殊字符不被shell或shell脚本重新解释或扩展。

某些程序和工具能够重新解释或者扩展被引用的特殊字符. 引用的一个重要作用就是保护命令行参数不被shell解释, 但是还是能够让正在调用的程序来扩展它. 

```bash
$ grep '[Ff]irst' *.txt
#[Ff]irst使用单引号扩起来保护其不被shell解释扩展，能正确被grep工具扩展
# 貌似bash下没有区别？
```

引用还可以改掉`echo`命令不换行的“毛病”。

```bash
echo $(ls -l)

echo "$(ls -l)"
```

#### 双引号
双引号引用称为“部分引用”，一般情况下双引号引用是字面意思，除非遇到如下特殊字符，`$`,```\`。保留`$`作为特殊字符的意义是为了能够在双引号中也能够正常的引用变量`("$variable")`, 也就是说, 这个变量将被它的值所取代.

使用双引号还能够阻止单词分割(word splitting)。如果一个参数被双引号扩起来的话, 那么这个参数将认为是一个单元, 即使这个参数包含有空白, 那里面的单词也不会被分隔开.

在echo语句中, 只有在单词分割(word splitting)或者需要保留空白的时候, 才需要把参数用双引号括起来. 

#### 单引号
单引号引用称为”全引用“，所有特殊字符按照字面意思解释，`$`特殊意义被关闭。

如果想在一对单引号中显示一个单引号是不行的。

### 转义
转义是一种引用单个字符的方法. 一个前面放上转义符 (\)的字符就是告诉shell这个字符按照字面的意思进行解释, 换句话说, 就是这个字符失去了它的特殊含义. 

在某些特定的命令和工具中, 比如echo和sed, 转义符往往会起到相反效果 - 它反倒可能会引发出这个字符的特殊含义。


echo和sed命令使用如下特殊字符：

---------------------------------------------------------------------
特殊字符                        含义
---------         --------------------------------------------------
 \\n                           新的一行

 \\r                             回车

 \\t                            水平制表符

 \\v                           垂直制表符

 \\b                             后退符

 \\a                          alert,蜂鸣

 \\0xx                          转换为八进制的ASCII码
 
 \\"                          引号字面意思

 \\$                `$`本身子面的含义(跟在`\$`后边的变量名将不能引用变量的值)
 
 `\\`                 反斜线字母意思

---------------------------------------------------------------------

## 退出状态码
`exit`被用来结束一个脚本, 就像在C语言中一样. 它也返回一个整数值, 并且这个整数值会传递给脚本的父进程, 父进程会使用这个值做下一步的处理. 

每个命令都会返回一个 退出状态码 (有时候也被称为 返回状态 ). 成功的命令返回0, 而不成功的命令返回非零值, 非零值通常都被解释成一个错误码. 行为良好的UNIX命令, 程序, 和工具都会返回0作为退出码来表示成功, 虽然偶尔也会有例外. 

同样的, 脚本中的函数和脚本本身也会返回退出状态码. 在脚本或者是脚本函数中执行的最后的命令会决定退出状态码. 在脚本中, exit nnn命令将会把	nnn退出码传递给shell(	nnn必须是十进制数, 范围必须是0 - 255).

脚本退出码获得的三种等价方法：

 * 当脚本以不带参数的exit命令来结束时, 脚本的退出状态码就由脚本中最后执行的命令来决定(就是exit之前的命令).

 * `exit $?`

 * 脚本的结尾不写exit

`$?`保存了最后所执行的命令的退出状态码. 当函数返回之后, `$?`保存函数中最后所执行的命令的退出状态码. 这就是bash对函数"返回值"的处理方法. 当一个脚本退出, `$?`保存了脚本的退出状态码, 这个退出状态码也就是脚本中最后一个执行命令的退出状态码. 一般情况下, 0表示成功, 在范围1 - 255的整数表示错误. 

`$?`用于测试脚本中的命令结果的时候, 往往显得特别有用.

	

`!`  逻辑 "非"操作符, 将会反转命令或条件测试的结果, 并且这会影响退出状态码. 

```
metman@ThinkPad:/tmp$ true
metman@ThinkPad:/tmp$ echo $?
0
metman@ThinkPad:/tmp$ ! true
metman@ThinkPad:/tmp$ echo $?
1
metman@ThinkPad:/tmp$ 
```

特定的退出状态码具有保留含义, 所以用户不应该在脚本中指定它. 


## 条件判断
### 条件测试结构

